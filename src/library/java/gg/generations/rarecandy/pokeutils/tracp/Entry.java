package gg.generations.rarecandy.pokeutils.tracp;// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

@SuppressWarnings("unused")
public final class Entry extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_23_5_26(); }
  public static Entry getRootAsEntry(ByteBuffer _bb) { return getRootAsEntry(_bb, new Entry()); }
  public static Entry getRootAsEntry(ByteBuffer _bb, Entry obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public Entry __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Animation animations(int j) { return animations(new Animation(), j); }
  public Animation animations(Animation obj, int j) { int o = __offset(4); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int animationsLength() { int o = __offset(4); return o != 0 ? __vector_len(o) : 0; }
  public Animation.Vector animationsVector() { return animationsVector(new Animation.Vector()); }
  public Animation.Vector animationsVector(Animation.Vector obj) { int o = __offset(4); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  public Moves moves(int j) { return moves(new Moves(), j); }
  public Moves moves(Moves obj, int j) { int o = __offset(6); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int movesLength() { int o = __offset(6); return o != 0 ? __vector_len(o) : 0; }
  public Moves.Vector movesVector() { return movesVector(new Moves.Vector()); }
  public Moves.Vector movesVector(Moves.Vector obj) { int o = __offset(6); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  public Switch switches(int j) { return switches(new Switch(), j); }
  public Switch switches(Switch obj, int j) { int o = __offset(8); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int switchesLength() { int o = __offset(8); return o != 0 ? __vector_len(o) : 0; }
  public Switch.Vector switchesVector() { return switchesVector(new Switch.Vector()); }
  public Switch.Vector switchesVector(Switch.Vector obj) { int o = __offset(8); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  public Trigger triggers(int j) { return triggers(new Trigger(), j); }
  public Trigger triggers(Trigger obj, int j) { int o = __offset(10); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int triggersLength() { int o = __offset(10); return o != 0 ? __vector_len(o) : 0; }
  public Trigger.Vector triggersVector() { return triggersVector(new Trigger.Vector()); }
  public Trigger.Vector triggersVector(Trigger.Vector obj) { int o = __offset(10); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }

  public static int createEntry(FlatBufferBuilder builder,
      int animationsOffset,
      int movesOffset,
      int switchesOffset,
      int triggersOffset) {
    builder.startTable(4);
    Entry.addTriggers(builder, triggersOffset);
    Entry.addSwitches(builder, switchesOffset);
    Entry.addMoves(builder, movesOffset);
    Entry.addAnimations(builder, animationsOffset);
    return Entry.endEntry(builder);
  }

  public static void startEntry(FlatBufferBuilder builder) { builder.startTable(4); }
  public static void addAnimations(FlatBufferBuilder builder, int animationsOffset) { builder.addOffset(0, animationsOffset, 0); }
  public static int createAnimationsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startAnimationsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addMoves(FlatBufferBuilder builder, int movesOffset) { builder.addOffset(1, movesOffset, 0); }
  public static int createMovesVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startMovesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSwitches(FlatBufferBuilder builder, int switchesOffset) { builder.addOffset(2, switchesOffset, 0); }
  public static int createSwitchesVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSwitchesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addTriggers(FlatBufferBuilder builder, int triggersOffset) { builder.addOffset(3, triggersOffset, 0); }
  public static int createTriggersVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startTriggersVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static int endEntry(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public Entry get(int j) { return get(new Entry(), j); }
    public Entry get(Entry obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
  public EntryT unpack() {
    EntryT _o = new EntryT();
    unpackTo(_o);
    return _o;
  }
  public void unpackTo(EntryT _o) {
    AnimationT[] _oAnimations = new AnimationT[animationsLength()];
    for (int _j = 0; _j < animationsLength(); ++_j) {_oAnimations[_j] = (animations(_j) != null ? animations(_j).unpack() : null);}
    _o.setAnimations(_oAnimations);
    MovesT[] _oMoves = new MovesT[movesLength()];
    for (int _j = 0; _j < movesLength(); ++_j) {_oMoves[_j] = (moves(_j) != null ? moves(_j).unpack() : null);}
    _o.setMoves(_oMoves);
    SwitchT[] _oSwitches = new SwitchT[switchesLength()];
    for (int _j = 0; _j < switchesLength(); ++_j) {_oSwitches[_j] = (switches(_j) != null ? switches(_j).unpack() : null);}
    _o.setSwitches(_oSwitches);
    TriggerT[] _oTriggers = new TriggerT[triggersLength()];
    for (int _j = 0; _j < triggersLength(); ++_j) {_oTriggers[_j] = (triggers(_j) != null ? triggers(_j).unpack() : null);}
    _o.setTriggers(_oTriggers);
  }
  public static int pack(FlatBufferBuilder builder, EntryT _o) {
    if (_o == null) return 0;
    int _animations = 0;
    if (_o.getAnimations() != null) {
      int[] __animations = new int[_o.getAnimations().length];
      int _j = 0;
      for (AnimationT _e : _o.getAnimations()) { __animations[_j] = Animation.pack(builder, _e); _j++;}
      _animations = createAnimationsVector(builder, __animations);
    }
    int _moves = 0;
    if (_o.getMoves() != null) {
      int[] __moves = new int[_o.getMoves().length];
      int _j = 0;
      for (MovesT _e : _o.getMoves()) { __moves[_j] = Moves.pack(builder, _e); _j++;}
      _moves = createMovesVector(builder, __moves);
    }
    int _switches = 0;
    if (_o.getSwitches() != null) {
      int[] __switches = new int[_o.getSwitches().length];
      int _j = 0;
      for (SwitchT _e : _o.getSwitches()) { __switches[_j] = Switch.pack(builder, _e); _j++;}
      _switches = createSwitchesVector(builder, __switches);
    }
    int _triggers = 0;
    if (_o.getTriggers() != null) {
      int[] __triggers = new int[_o.getTriggers().length];
      int _j = 0;
      for (TriggerT _e : _o.getTriggers()) { __triggers[_j] = Trigger.pack(builder, _e); _j++;}
      _triggers = createTriggersVector(builder, __triggers);
    }
    return createEntry(
      builder,
      _animations,
      _moves,
      _switches,
      _triggers);
  }
}

