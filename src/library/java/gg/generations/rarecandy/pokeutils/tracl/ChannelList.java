package gg.generations.rarecandy.pokeutils.tracl;// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.Table;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

@SuppressWarnings("unused")
public final class ChannelList extends Table {
    public static void ValidateVersion() {
        Constants.FLATBUFFERS_23_5_26();
    }

    public static ChannelList getRootAsChannelList(ByteBuffer _bb) {
        return getRootAsChannelList(_bb, new ChannelList());
    }

    public static ChannelList getRootAsChannelList(ByteBuffer _bb, ChannelList obj) {
        _bb.order(ByteOrder.LITTLE_ENDIAN);
        return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb));
    }

    public void __init(int _i, ByteBuffer _bb) {
        __reset(_i, _bb);
    }

    public ChannelList __assign(int _i, ByteBuffer _bb) {
        __init(_i, _bb);
        return this;
    }

    public boolean isList() {
        int o = __offset(4);
        return o != 0 ? 0 != bb.get(o + bb_pos) : false;
    }

    public ChannelName list(int j) {
        return list(new ChannelName(), j);
    }

    public ChannelName list(ChannelName obj, int j) {
        int o = __offset(6);
        return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null;
    }

    public int listLength() {
        int o = __offset(6);
        return o != 0 ? __vector_len(o) : 0;
    }

    public ChannelName.Vector listVector() {
        return listVector(new ChannelName.Vector());
    }

    public ChannelName.Vector listVector(ChannelName.Vector obj) {
        int o = __offset(6);
        return o != 0 ? obj.__assign(__vector(o), 4, bb) : null;
    }

    public static int createChannelList(FlatBufferBuilder builder,
                                        boolean isList,
                                        int listOffset) {
        builder.startTable(2);
        ChannelList.addList(builder, listOffset);
        ChannelList.addIsList(builder, isList);
        return ChannelList.endChannelList(builder);
    }

    public static void startChannelList(FlatBufferBuilder builder) {
        builder.startTable(2);
    }

    public static void addIsList(FlatBufferBuilder builder, boolean isList) {
        builder.addBoolean(0, isList, false);
    }

    public static void addList(FlatBufferBuilder builder, int listOffset) {
        builder.addOffset(1, listOffset, 0);
    }

    public static int createListVector(FlatBufferBuilder builder, int[] data) {
        builder.startVector(4, data.length, 4);
        for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]);
        return builder.endVector();
    }

    public static void startListVector(FlatBufferBuilder builder, int numElems) {
        builder.startVector(4, numElems, 4);
    }

    public static int endChannelList(FlatBufferBuilder builder) {
        int o = builder.endTable();
        return o;
    }

    public static final class Vector extends BaseVector {
        public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) {
            __reset(_vector, _element_size, _bb);
            return this;
        }

        public ChannelList get(int j) {
            return get(new ChannelList(), j);
        }

        public ChannelList get(ChannelList obj, int j) {
            return obj.__assign(__indirect(__element(j), bb), bb);
        }
    }

    public ChannelListT unpack() {
        ChannelListT _o = new ChannelListT();
        unpackTo(_o);
        return _o;
    }

    public void unpackTo(ChannelListT _o) {
        boolean _oIsList = isList();
        _o.setIsList(_oIsList);
        ChannelNameT[] _oList = new ChannelNameT[listLength()];
        for (int _j = 0; _j < listLength(); ++_j) {
            _oList[_j] = (list(_j) != null ? list(_j).unpack() : null);
        }
        _o.setList(_oList);
    }

    public static int pack(FlatBufferBuilder builder, ChannelListT _o) {
        if (_o == null) return 0;
        int _list = 0;
        if (_o.getList() != null) {
            int[] __list = new int[_o.getList().length];
            int _j = 0;
            for (ChannelNameT _e : _o.getList()) {
                __list[_j] = ChannelName.pack(builder, _e);
                _j++;
            }
            _list = createListVector(builder, __list);
        }
        return createChannelList(
                builder,
                _o.getIsList(),
                _list);
    }
}

